{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Erebus documentation","text":"<p>Erebus is a rocky-exoplanet secondary eclipse aperture-photometry pipeline made for use with the Mid Infra-Red Instrument aboard the James Webb Space Telescope, starting with <code>calints.fits</code> files available on the Barbara A. Mikulski Archive for Space Telescopes.</p> <p>For issue reporting or feedback suggestions click here.</p> <p>For the setup used when writing Connors et al. 2025 click here.</p>"},{"location":"api_config/","title":"API - Configuring Erebus","text":"<p><p>Planet</p> </p> <p>Class which represents known planet values with uncertainties. Loaded from a yaml file and optionally validated against a schema. Uncertainties are expressed by writing the values into the yaml file as a list of floats, where the first value is the absolute value of the measurement. The second value is taken as the symmetric error, and if a third value is provided it is taken a the upper error.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the planet.</p> <code>t0</code> <code>uncertainties.core.Variable | float</code> <p>The last known time of conjunction of the planet.</p> <code>a_rstar</code> <code>uncertainties.core.Variable | float</code> <p>The ratio of semi-major axis to star radius.</p> <code>p</code> <code>uncertainties.core.Variable | float</code> <p>The period of the planet in days.</p> <code>rp_rstar</code> <code>uncertainties.core.Variable | float</code> <p>The ratio of the planet's radius to the star's radius.</p> <code>inc</code> <code>uncertainties.core.Variable | float</code> <p>The inclination of the planet in degrees.</p> <code>ecc</code> <code>uncertainties.core.Variable | float</code> <p>The eccentricity of the planet (0 inclusive to 1 exclusive).</p> <code>w</code> <code>uncertainties.core.Variable | float</code> <p>The argument of periastron of the planet (degrees).</p> <p><p>ErebusRunConfig</p> </p> <p>               Bases: <code>pydantic.BaseModel</code></p> <p>Settings for running through the entire Erebus pipeline. Serializable to/from YAML. One of perform_joint_fit or perform_individual_fits must be true else the run will not do anything.</p> <p>Attributes:</p> Name Type Description <code>fit_fnpca</code> <code>bool</code> <p>Optional bool to use FN-PCA in the systematic model.</p> <code>fit_exponential</code> <code>bool</code> <p>Optional bool to use an exponential curve in the systematic model.</p> <code>fit_linear</code> <code>bool</code> <p>Optional bool to use a linear slope in the systematic model.</p> <code>perform_joint_fit</code> <code>bool</code> <p>Optional bool to fit all visits together with a shared eclipse depth.</p> <code>perform_individual_fits</code> <code>bool</code> <p>Optional bool to fit each visit with their own eclipse depth.</p> <code>calints_path</code> <code>str</code> <p>Relative path from the folder containing this file to where the .fits files are.</p> <code>planet_path</code> <code>str</code> <p>Relative path from the folder containing this file to where the planet config is.</p> <code>aperture_radius</code> <code>int</code> <p>Pixel radius for aperture photometry.</p> <code>annulus_start</code> <code>int</code> <p>Inner pixel radius of disk used for background subtraction.</p> <code>annulus_end</code> <code>int</code> <p>Outer pixel radius of disk used for background subtraction.</p> <code>skip_visits</code> <code>list[int]</code> <p>Optional list of indices to skip when doing individual fits. Index based on visit ID.</p> <code>trim_integrations</code> <code>list[int]</code> <p>Length-two list with the number of integrations to clip from the start and end. Optional.</p> <code>star_position</code> <code>list[int]</code> <p>X and y pixel coordinates of the star. Optional (will search for the star or assume its centered).</p>"},{"location":"api_fnpca/","title":"API - Frame Normalized PCA","text":"<p>The <code>frame_normalized_pca.py</code> file contains helper methods for doing FN-PCA as part of or outside of the Erebus pipeline.</p>"},{"location":"api_fnpca/#frame_normalized_pca","title":"<code>frame_normalized_pca</code>","text":""},{"location":"api_fnpca/#frame_normalized_pca.perform_fn_pca_on_aperture","title":"<code>perform_fn_pca_on_aperture(aperture_frames: np.ndarray) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>Performs Frame-Normalized PCA on a photometric time series data set. Expects the star to be centered on each frame. Expects each frame to already be normalized and background subtracted, with pixels outside the aperture set to 0.</p> <p>Returns the eigenvalue-eigenimage pairs and ratios of explained variance.</p>"},{"location":"api_fnpca/#frame_normalized_pca.perform_fnpca_on_full_frame","title":"<code>perform_fnpca_on_full_frame(frames: np.ndarray, radius: int, annulus_start: int, annulus_end: int) -&gt; Tuple[np.ndarray, np.ndarray]</code>","text":"<p>Performs Frame-Normalized PCA on a photometric time series data set. Expects the star to be centered on each frame.</p> <p>Returns the eigenvalue-eigenimage pairs and ratios of explained variance.</p>"},{"location":"api_results/","title":"API - Viewing results","text":"<p>After running an instance of the <code>Erebus</code> pipeline, a folder of results files are generated. These can be loaded in later in order to plot and otherwise visualize your results.</p> <p>IndividualFitResults</p> <p>JointFitResults</p> <p>Plotting helper methods</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults","title":"<code>individual_fit_results.IndividualFitResults</code>","text":"<p>               Bases: <code>erebus.utility.h5_serializable_file.H5Serializable</code></p> <p>Class containing the results of an individual fit run</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.config","title":"<code>config = fit.config</code>  <code>instance-attribute</code>","text":"<p>The config file used to create this run</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.config_hash","title":"<code>config_hash = fit.config_hash</code>  <code>instance-attribute</code>","text":"<p>The unique hash of the config file. Used for naming cache files.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.eigenvalues","title":"<code>eigenvalues = fit.eigenvalues</code>  <code>instance-attribute</code>","text":"<p>For each principal component, the eigenvalue. The first 5 are used as the FN-PCA systematic model.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.eigenvectors","title":"<code>eigenvectors = fit.eigenvectors</code>  <code>instance-attribute</code>","text":"<p>For each principal component, this is its eigenimage.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.flux_model","title":"<code>flux_model = fit.fit_method(fit.time, *res_nominal_values)</code>  <code>instance-attribute</code>","text":"<p>The best fit detrended lightcurve.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.frames","title":"<code>frames = fit.photometry_data.normalized_frames</code>  <code>instance-attribute</code>","text":"<p>The frames which aperture photometry was performed on for the fit.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.order","title":"<code>order = fit.order</code>  <code>instance-attribute</code>","text":"<p>If there were other visits observed, this is the numerical ordering they occuring in.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.pca_variance_ratios","title":"<code>pca_variance_ratios = fit.pca_variance_ratios</code>  <code>instance-attribute</code>","text":"<p>For each principal component, how much of the variance does it explain.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.planet_name","title":"<code>planet_name = fit.planet_name</code>  <code>instance-attribute</code>","text":"<p>The name of the planet observed</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.raw_flux","title":"<code>raw_flux = fit.raw_flux</code>  <code>instance-attribute</code>","text":"<p>Light curve that is not yet detrended.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.results","title":"<code>results = fit.results</code>  <code>instance-attribute</code>","text":"<p>A dictionary of results for the fit parameters (e.g., eclipse depth)</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.start_time","title":"<code>start_time = fit.start_time</code>  <code>instance-attribute</code>","text":"<p>The BJD date the observation started on.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.systematic_factor","title":"<code>systematic_factor = fit.systematic_model(fit.time, *systematic_params)</code>  <code>instance-attribute</code>","text":"<p>The systematic factor which was divided out of the raw lightcurve to get the detrended one.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.time","title":"<code>time = fit.time</code>  <code>instance-attribute</code>","text":"<p>The time values that the model was fit on. Starts at 0.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.visit_name","title":"<code>visit_name = fit.visit_name</code>  <code>instance-attribute</code>","text":"<p>The unique visit name as read on MAST.</p>"},{"location":"api_results/#individual_fit_results.IndividualFitResults.load","title":"<code>load(path: str)</code>  <code>staticmethod</code>","text":"<p>After running an Erebus instance, the results file can be loaded later using this method.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults","title":"<code>joint_fit_results.JointFitResults</code>","text":"<p>               Bases: <code>erebus.utility.h5_serializable_file.H5Serializable</code></p> <p>Class containing the results of an individual fit run</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.config","title":"<code>config = fit.config</code>  <code>instance-attribute</code>","text":"<p>The config file used to create this run</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.config_hash","title":"<code>config_hash = fit.config_hash</code>  <code>instance-attribute</code>","text":"<p>The unique hash of the config file. Used for naming cache files.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.detrended_flux_per_visit","title":"<code>detrended_flux_per_visit = []</code>  <code>instance-attribute</code>","text":"<p>A list containing the detrended lightcurves of each visit.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.joint_eigenvalues","title":"<code>joint_eigenvalues = fit.joint_eigenvalues</code>  <code>instance-attribute</code>","text":"<p>A list of eigenvalue lists per visit. Index first by vist number than by principal component number.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.joint_eigenvectors","title":"<code>joint_eigenvectors = fit.joint_eigenvectors</code>  <code>instance-attribute</code>","text":"<p>A list of eigenvector lists per visit. Index first by vist number than by principal component number.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.model_flux_per_visit","title":"<code>model_flux_per_visit = []</code>  <code>instance-attribute</code>","text":"<p>The best fit detrended lightcurves per visit.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.model_time_per_visit","title":"<code>model_time_per_visit = []</code>  <code>instance-attribute</code>","text":"<p>A list containing the time values corresponding to model_flux_per_visit</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.pca_variance_ratios","title":"<code>pca_variance_ratios = fit.pca_variance_ratios</code>  <code>instance-attribute</code>","text":"<p>A list of PCA explained variance ratio lists per visit. Index first by vist number than by principal component number.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.planet_name","title":"<code>planet_name = fit.planet_name</code>  <code>instance-attribute</code>","text":"<p>The name of the planet observed</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.raw_flux","title":"<code>raw_flux = fit.raw_flux</code>  <code>instance-attribute</code>","text":"<p>A list containing the raw (not yet detrended) lightcurves of each visit.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.relative_time_per_visit","title":"<code>relative_time_per_visit = []</code>  <code>instance-attribute</code>","text":"<p>A list containing the time values corresponding to detrended_flux_per_visit</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.results","title":"<code>results = fit.results</code>  <code>instance-attribute</code>","text":"<p>A dictionary of results for the fit parameters (e.g., eclipse depth)</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.time","title":"<code>time = fit.time</code>  <code>instance-attribute</code>","text":"<p>A list of time values for each visit.</p>"},{"location":"api_results/#joint_fit_results.JointFitResults.load","title":"<code>load(path: str)</code>  <code>staticmethod</code>","text":"<p>After running an Erebus instance, the results file can be loaded later using this method.</p>"},{"location":"api_results/#plotting","title":"<code>plotting</code>","text":""},{"location":"api_results/#plotting.chain_plot","title":"<code>chain_plot(mcmc: WrappedMCMC, save_to_path: str = None, show: bool = False)</code>","text":"<p>Call this on an MCMC model after it has run in order to show and optionally save a chain plot.</p>"},{"location":"api_results/#plotting.corner_plot","title":"<code>corner_plot(mcmc: WrappedMCMC, save_to_path: str = None, show: bool = False)</code>","text":"<p>Call this on an MCMC model after it has run in order to show and optionally save a corner plot.</p>"},{"location":"api_results/#plotting.plot_eigenvectors","title":"<code>plot_eigenvectors(individual_fit: IndividualFit, save_to_directory: str = None)</code>","text":"<p>Plots the 5 highest ranked eigenimages to a given folder (if provided).</p>"},{"location":"api_results/#plotting.plot_fnpca_individual_fit","title":"<code>plot_fnpca_individual_fit(individual_fit: IndividualFit | IndividualFitResults, save_to_directory: str = None, show: bool = False)</code>","text":"<p>Creates an informative plot for an individual fit. Will save both a png and a pdf. Expects the individual fit to be done with fnpca/exponential and a linear component.</p>"},{"location":"api_results/#plotting.plot_joint_fit","title":"<code>plot_joint_fit(joint_fit: JointFit | JointFitResults, save_to_directory: str = None, show: bool = False)</code>","text":"<p>Creates an informative plot for the joint fit results. Saves as a png and a pdf.</p> <p>File name starts with true/false for if FNPCA was used, then planet name, then visit name, then unique hash of config file settings.</p>"},{"location":"api_run/","title":"API - Running the tool","text":"<p>For normal use it should suffice to use only the <code>Erebus</code> class. The <code>WrappedFits</code>, <code>PhotometryData</code>, and <code>WrappedMCMC</code> classes give control over each step of the process.</p> <p>Erebus</p> <p>WrappedFits</p> <p>PhotometryData</p> <p>WrappedMCMC</p>"},{"location":"api_run/#erebus.Erebus","title":"<code>erebus.Erebus</code>","text":"<p>               Bases: <code>erebus.utility.h5_serializable_file.H5Serializable</code></p> <p>Object instance for running the full pipeline, starting from calints files.</p>"},{"location":"api_run/#erebus.Erebus.config","title":"<code>config: ErebusRunConfig = run_cfg</code>  <code>instance-attribute</code>","text":"<p>The configuration file used for this instance of the Erebus pipeline.</p>"},{"location":"api_run/#erebus.Erebus.individual_fits","title":"<code>individual_fits: list[IndividualFit] = []</code>  <code>instance-attribute</code>","text":"<p>The individual fit instances of each visit.</p>"},{"location":"api_run/#erebus.Erebus.joint_fit","title":"<code>joint_fit: JointFit = None</code>  <code>instance-attribute</code>","text":"<p>The joint fit instance.</p>"},{"location":"api_run/#erebus.Erebus.photometry","title":"<code>photometry: list[PhotometryData] = []</code>  <code>instance-attribute</code>","text":"<p>The photometry data of each visit.</p>"},{"location":"api_run/#erebus.Erebus.planet","title":"<code>planet = Planet(planet_path)</code>  <code>instance-attribute</code>","text":"<p>The planet configuration file used for this instance of the pipeline</p>"},{"location":"api_run/#erebus.Erebus.visit_names","title":"<code>visit_names: list[str] = []</code>  <code>instance-attribute</code>","text":"<p>The unique names of each visit.</p>"},{"location":"api_run/#erebus.Erebus.load","title":"<code>load(path: str)</code>  <code>staticmethod</code>","text":"<p>Helper method to directly load an Erebus instance cache file.</p>"},{"location":"api_run/#erebus.Erebus.run","title":"<code>run(force_clear_cache: bool = False, output_folder='./output_{DATE}/')</code>","text":"<p>Performs all individual and joint fits. Results and plots are saved to the given folder. Output folder can optionally include the current time by writing {DATE}</p>"},{"location":"api_run/#wrapped_fits.WrappedFits","title":"<code>wrapped_fits.WrappedFits</code>","text":"<p>               Bases: <code>erebus.utility.h5_serializable_file.H5Serializable</code></p> <p>A class wrapping the flux and time data from the calints fits files of a single visit If the star pixel position is not provided we will fit for it Contains the flux in a 127x127 pixel region centered around the star Performs outerlier rejection and interpolation of bad pixels.</p> <p>Acts as the equivalent to a JWST Stage 3 input to the Erebus pipeline.</p>"},{"location":"api_run/#wrapped_fits.WrappedFits.frames","title":"<code>frames = []</code>  <code>instance-attribute</code>","text":"<p>3D array respresenting time series images making up this observation.</p>"},{"location":"api_run/#wrapped_fits.WrappedFits.raw_frames","title":"<code>raw_frames = []</code>  <code>instance-attribute</code>","text":"<p>3D array respresenting time series images making up this observation, before performing outlier and nan rejection.</p>"},{"location":"api_run/#wrapped_fits.WrappedFits.source_folder","title":"<code>source_folder: str = source_folder</code>  <code>instance-attribute</code>","text":"<p>The directory containing the files this WrappedFits is based on</p>"},{"location":"api_run/#wrapped_fits.WrappedFits.time","title":"<code>time: list[float] = []</code>  <code>instance-attribute</code>","text":"<p>The time values loaded from the corresponding fits files</p>"},{"location":"api_run/#wrapped_fits.WrappedFits.visit_name","title":"<code>visit_name: str = visit_name</code>  <code>instance-attribute</code>","text":"<p>The unique name of the visit being observed.</p>"},{"location":"api_run/#wrapped_fits.WrappedFits.load","title":"<code>load(path: str)</code>  <code>staticmethod</code>","text":"<p>Helper method to directly load a WrappedFits instance cache file.</p>"},{"location":"api_run/#photometry_data.PhotometryData","title":"<code>photometry_data.PhotometryData</code>","text":"<p>               Bases: <code>erebus.utility.h5_serializable_file.H5Serializable</code></p> <p>A class representing the photometric data from a single visit loaded from a calints fits file with a specific aperture and annulus</p> <p>Also prepares frames for FN PCA</p> <p>Acts as Stage 3 of the Erebus pipeline</p>"},{"location":"api_run/#photometry_data.PhotometryData.annulus_end","title":"<code>annulus_end = annulus[1]</code>  <code>instance-attribute</code>","text":"<p>Outer pixel radius of the annulus used for background subtraction when doing aperture photometry.</p>"},{"location":"api_run/#photometry_data.PhotometryData.annulus_start","title":"<code>annulus_start = annulus[0]</code>  <code>instance-attribute</code>","text":"<p>Inner pixel radius of the annulus used for background subtraction when doing aperture photometry.</p>"},{"location":"api_run/#photometry_data.PhotometryData.fits_file_location","title":"<code>fits_file_location = os.path.abspath(fits_file._cache_file)</code>  <code>instance-attribute</code>","text":"<p>Absolute path of the cache file for the fits file that aperture photometry was performed on.</p>"},{"location":"api_run/#photometry_data.PhotometryData.normalized_frames","title":"<code>normalized_frames = []</code>  <code>instance-attribute</code>","text":"<p>Normalized and background subtracted frames used for performing FN-PCA.</p>"},{"location":"api_run/#photometry_data.PhotometryData.radius","title":"<code>radius = radius</code>  <code>instance-attribute</code>","text":"<p>Pixel radius used for aperture photometry.</p>"},{"location":"api_run/#photometry_data.PhotometryData.raw_flux","title":"<code>raw_flux = []</code>  <code>instance-attribute</code>","text":"<p>Raw flux from the star after performing background subtraction.</p>"},{"location":"api_run/#photometry_data.PhotometryData.source_folder","title":"<code>source_folder: str = fits_file.source_folder</code>  <code>instance-attribute</code>","text":"<p>The directory containing the files this WrappedFits is based on</p>"},{"location":"api_run/#photometry_data.PhotometryData.time","title":"<code>time = fits_file.time</code>  <code>instance-attribute</code>","text":"<p>The time values loaded from the corresponding fits files.</p>"},{"location":"api_run/#photometry_data.PhotometryData.visit_name","title":"<code>visit_name: str = fits_file.visit_name</code>  <code>instance-attribute</code>","text":"<p>The unique name of the visit being observed.</p>"},{"location":"api_run/#photometry_data.PhotometryData.load","title":"<code>load(path: str)</code>  <code>staticmethod</code>","text":"<p>Helper method to directly load a PhotometryData instance cache file.</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC","title":"<code>mcmc_model.WrappedMCMC</code>","text":"<p>Wrapper class for emcee User can define a method that is to be fit and parameters with Bayesian priors The model will always fit for a Gaussian noise parameter \"y_err\"</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.auto_correlation","title":"<code>auto_correlation = 0</code>  <code>instance-attribute</code>","text":"<p>The integrated autocorrelation time after the MCMC has finished running</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.iterations","title":"<code>iterations = 0</code>  <code>instance-attribute</code>","text":"<p>How many iterations this MCMC ran for before stopping.</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.model_function","title":"<code>model_function: Callable[[Any], float] = None</code>  <code>instance-attribute</code>","text":"<p>The function to be fit</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.params","title":"<code>params: dict = {}</code>  <code>instance-attribute</code>","text":"<p>Dictionary of parameters. Each is a bayesian_parameter instance.</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.results","title":"<code>results: dict = {}</code>  <code>instance-attribute</code>","text":"<p>Dictionary of results after fitting</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.sampler","title":"<code>sampler: emcee.EnsembleSampler = None</code>  <code>instance-attribute</code>","text":"<p>The emcee EnsembleSampler which this class wrapped</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.add_parameter","title":"<code>add_parameter(name: str, param: Parameter)</code>","text":"<p>Adds bayesian parameters to our method, must be called before set_method</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.evaluate_model","title":"<code>evaluate_model(x: np.ndarray, *params: list[Parameter]) -&gt; float</code>","text":"<p>Evaluates the model with the given x input and parameters</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.get_free_params","title":"<code>get_free_params() -&gt; list[Parameter]</code>","text":"<p>Returns the keys of any parameter that isn't fixed i.e., will be fitted for</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.log_likelihood","title":"<code>log_likelihood(theta: list[float], x: float, y: float)</code>","text":"<p>Given the parameters theta and the x and y values, calculates the Bayesian log likelihood.</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.run","title":"<code>run(x, y, max_steps=100000, walkers=64) -&gt; tuple[np.ndarray, emcee.EnsembleSampler, float, int]</code>","text":"<p>Runs the MCMC, gets the results (with errors), ensemble sampler instance, autocorrelation time, and interation count</p>"},{"location":"api_run/#mcmc_model.WrappedMCMC.set_method","title":"<code>set_method(method: Callable[[Any], float])</code>","text":"<p>Updates the method which will be fit for, and verifies that the method signature matches the parameters specified First parameter must be 'x' After that the order which parameters were added in must match their positions in the method signature</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Erebus is made with Python 3.12. To develop, create a fresh conda environment in this version and then install the dependencies in requirements.txt.</p> <p>I am not currently seeking contritions but have written this for posterity and the sake of internal documentation. However, please report any bugs encounted via the issues tab on the GitHub repository, and feel free to suggest features which could be used to improve the user experience.</p>"},{"location":"contributing/#building-erebus-locally","title":"Building Erebus locally","text":"<p>Releases are handled via GitHub workflow, however you may still want to build a local version for testing. To do this, run <code>./install.sh</code> in the repository root to build and install Erebus in your current Conda environment.</p>"},{"location":"contributing/#writing-new-documentation","title":"Writing new documentation","text":"<p>Documentation for Erebus is made using MkDocs and hosted using GitHub pages. A separate version of the docs is made per version. The main branch is published as <code>latest</code> and the dev branch is published as <code>dev</code>, and previous versions of the software are to be kept in their own branches labeled with their version number.</p> <p>The docs have their own separate requirements, but the same Python version as the tool itself.</p> <pre><code>pip install mkdocs-material\npip install pillow cairosvg mike\npip install mkdocstrings-python\npip install markdown-include\npip install mkdocs-jupyter\npip install griffe-pydantic\n</code></pre> <p>When these are installed, open a terminal from the root of the repo and run <code>mkdocs serve</code> to host the site locally. The local adress will be displayed to you.</p> <p>Any new functionality added to Erebus must be documented.</p>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Before making a pull request, run all manual tests locally on your branch and ensure they all work as expected and without logging errors. Similarly any maintainer should run all manual tests locally before merging a pull request after providing a thorough code review.</p>"},{"location":"contributing/#semantic-versioning","title":"Semantic versioning","text":"<p>Semantic versioning or semver is a simple set of rules for interpreting version numbers. Whenever making an update to Erebus we should strive to ensure there is backwards compatibility, and only when that is no longer tenable should we make a major release. Any deprecated functionality must remain in Erebus and not be removed unless part of a major version update (e.g., 1.x.x -&gt; 2.0.0).</p>"},{"location":"copyright/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Nicholas Connors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"installation/","title":"Erebus installation","text":"<p>It is recommended to use erebus in a dedicated Anaconda environment. For instructions on how to install Anaconda, read their docs. For the quickest setup use Miniconda.</p> <p>Next, create a new conda environment on Python 3.12 by running the following in the terminal (feel free to rename the environment).</p> <pre><code>conda create --name erebus_env\nconda activate erebus_env\nconda install python=3.12\n</code></pre>"},{"location":"installation/#installation-using-pip","title":"Installation using pip","text":"<p>Todo, once Erebus has been added to PyPI.</p>"},{"location":"installation/#manual-installation","title":"Manual installation","text":"<p>Download the Erebus installation file on the GitHub repo from the latest release or from an action artifact (Actions tab, build dev package artifact, erebus file at the bottom).</p> <p>If using the action artifact, unzip <code>erebus.zip</code> to get access to the <code>.tar.gz</code> file</p> <p>Navigate to the folder containing the archive file and run the following from your conda environment (substituting in the actual file name):</p> <pre><code>pip install erebus-x.y.z.tar.gz\n</code></pre>"},{"location":"installation/#installing-from-cloned-repo","title":"Installing from cloned repo","text":"<p>If you are installing Erebus for local development, see the Contributing page for how to build from the source code.</p>"},{"location":"installation/#running-jupyter-notebook-demos","title":"Running Jupyter Notebook demos","text":"<p>Demo notebooks can be found at https://github.com/nicholasconnors/erebus/docs/demos</p> <p>To set up Jupyter to run in your conda environment, run:</p> <pre><code>conda install jupyter\nconda install -c anaconda ipykernel\npython -m ipykernel install --user --name=erebus_env\njupyter notebook\n</code></pre> <p>To test that Erebus has installed correctly simply run a notebook with</p> <pre><code>import erebus\n</code></pre>"},{"location":"planet_config/","title":"Planet config","text":"<p>To find the parameters for a planet we recommend you use the Exoplanet Archive where <code>t0</code> is the time of conjunction (<code>tc</code> on the Exoplanet archive), <code>p</code> is the orbital period in days, <code>rp_rstar</code> is the ratio of the planet's radius to the star's radius, <code>a_rstar</code> is the ratio of the planet's semi-major axis to the star's radius, <code>inc</code> is the inclination of the planet (in degrees), <code>ecc</code> is the eccentricity of the planet (0 inclusive to 1 exclusive), and <code>w</code> is the agument of periastron of the planet (in degrees).</p> <p>Orbital parameters are given as a list. The first value is the absolute measurement. The second value (if provided) is the symmetrical error on the measurement; eg, [1, 0.1] = 1 +/- 0.1. The third value (if provided) is the upper error on the measurement, with the second value now taken as the lower error; eg, [1, 0.1, 0.2] = 1 (+ 0.1/- 0.2).</p>"},{"location":"demos/fnpca_systematic/","title":"Frame Normalized PCA example","text":"In\u00a0[1]: Copied! <pre>from erebus.utility.fits_file_utils import get_fits_files_visits_in_folder\n\nfolder = \"../../manual_tests/mast_lhs1478b\"\nvisits = get_fits_files_visits_in_folder(folder)\n\nprint(f\"In the folder {folder} there are {len(visits)} visits: {visits}\")\n</pre> from erebus.utility.fits_file_utils import get_fits_files_visits_in_folder  folder = \"../../manual_tests/mast_lhs1478b\" visits = get_fits_files_visits_in_folder(folder)  print(f\"In the folder {folder} there are {len(visits)} visits: {visits}\") <pre>In the folder ../../manual_tests/mast_lhs1478b there are 2 visits: ['jw03730012001' 'jw03730013001']\n</pre> In\u00a0[2]: Copied! <pre>from erebus.wrapped_fits import WrappedFits\n\nfits = WrappedFits(folder, visits[0])\n</pre> from erebus.wrapped_fits import WrappedFits  fits = WrappedFits(folder, visits[0]) In\u00a0[3]: Copied! <pre>from erebus.frame_normalized_pca import perform_fnpca_on_full_frame\n\n# Using a radius of 5 pixels and an annulus spanning 10 to 20 pixels\neigenvalues, eigenvectors, variance_ratio = perform_fnpca_on_full_frame(fits.frames, 5, 10, 20)\n\n# For a given principal component, the each number in the eigenvalues corresponds to a time\ntime = fits.t\n</pre> from erebus.frame_normalized_pca import perform_fnpca_on_full_frame  # Using a radius of 5 pixels and an annulus spanning 10 to 20 pixels eigenvalues, eigenvectors, variance_ratio = perform_fnpca_on_full_frame(fits.frames, 5, 10, 20)  # For a given principal component, the each number in the eigenvalues corresponds to a time time = fits.t <p>This method returns three arrays, where each index corresponds to a principal component.</p> <p>Each principal component has an eigenvalue/eigenvector pair, and a variance ratio indictating how much of the total variance in the time series is caused by that component. The eigenvalues can be used for modelling systematic trends (i.e., a systematic model made of a linear combination of the top 5 highest variance components). The eigenvectors are useful in identifying the nature of the systematic effect represented by the principal component.</p> <p>Below is an example of visualizing the eigenvalue/eigenvector pairs from this visit of LHS1478b</p> In\u00a0[4]: Copied! <pre>import matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, index):\n\tfig = plt.figure(figsize=(6, 3)) \n\tgs = fig.add_gridspec(1, 3)\n\t\n\tax1 = fig.add_subplot(gs[0, 0])\n\tax2 = fig.add_subplot(gs[0, 1:])\n\t\n\tax1.imshow(eigenvectors[index])\n\tax1.set_title(f\"Eigenvector\")\n\tax1.axis('off')\n\t\n\tax2.plot(time - np.min(time), eigenvalues[index])\n\tax2.set_title(\"Eigenvalue\")\n\tax2.set_xlabel(\"Time from start of observation (days)\")\n\tax2.yaxis.set_visible(False)\n\n\tplt.suptitle(f\"Principal component #{index+1} ({(variance_ratio[index]*100):.0f}% of the variance)\")\n\t\n\tplt.tight_layout()\n\tplt.show()\n\nplot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, 0)\nplot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, 1)\nplot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, 2)\n</pre> import matplotlib.pyplot as plt import numpy as np  def plot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, index): \tfig = plt.figure(figsize=(6, 3))  \tgs = fig.add_gridspec(1, 3) \t \tax1 = fig.add_subplot(gs[0, 0]) \tax2 = fig.add_subplot(gs[0, 1:]) \t \tax1.imshow(eigenvectors[index]) \tax1.set_title(f\"Eigenvector\") \tax1.axis('off') \t \tax2.plot(time - np.min(time), eigenvalues[index]) \tax2.set_title(\"Eigenvalue\") \tax2.set_xlabel(\"Time from start of observation (days)\") \tax2.yaxis.set_visible(False)  \tplt.suptitle(f\"Principal component #{index+1} ({(variance_ratio[index]*100):.0f}% of the variance)\") \t \tplt.tight_layout() \tplt.show()  plot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, 0) plot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, 1) plot_principal_component(eigenvalues, eigenvectors, variance_ratio, time, 2) <p>We see a huge source of error occuring near the end of the observation: We can trim this from the data and repeat the FN-PCA</p> In\u00a0[5]: Copied! <pre>from erebus.frame_normalized_pca import perform_fnpca_on_full_frame\n\ntrimmed_eigenvalues, trimmed_eigenvectors, trimmed_variance_ratio = perform_fnpca_on_full_frame(fits.frames[:-40], 5, 10, 20)\ntrimmed_time = fits.t[:-40]\n</pre> from erebus.frame_normalized_pca import perform_fnpca_on_full_frame  trimmed_eigenvalues, trimmed_eigenvectors, trimmed_variance_ratio = perform_fnpca_on_full_frame(fits.frames[:-40], 5, 10, 20) trimmed_time = fits.t[:-40] In\u00a0[6]: Copied! <pre>plot_principal_component(trimmed_eigenvalues, trimmed_eigenvectors, trimmed_variance_ratio, trimmed_time, 0)\nplot_principal_component(trimmed_eigenvalues, trimmed_eigenvectors, trimmed_variance_ratio, trimmed_time, 1)\n</pre> plot_principal_component(trimmed_eigenvalues, trimmed_eigenvectors, trimmed_variance_ratio, trimmed_time, 0) plot_principal_component(trimmed_eigenvalues, trimmed_eigenvectors, trimmed_variance_ratio, trimmed_time, 1) <p>With principal component analysis it is also useful to compare the variance ratios of each component, which results in an elbow shaped plot:</p> In\u00a0[7]: Copied! <pre>plt.plot(np.arange(1, 11), trimmed_variance_ratio[:10] * 100, marker='o')\nplt.ylabel(\"Explained variance (percent)\")\nplt.xlabel(\"Principal component number\")\nplt.show()\n</pre> plt.plot(np.arange(1, 11), trimmed_variance_ratio[:10] * 100, marker='o') plt.ylabel(\"Explained variance (percent)\") plt.xlabel(\"Principal component number\") plt.show() In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"demos/fnpca_systematic/#frame-normalized-pca-example","title":"Frame Normalized PCA example\u00b6","text":"<p>The Erebus pipeline uses Principal Component Analysis (PCA) on the normalized time-series frames of an exoplanet eclipse observation, in order to remove the effects of astrophysical sources and be left only with pixel-level systematic effects (see Connors et al 2025). Principal component analysis is a dimensionality reduction technique: read more on Wikipedia.</p> <p>There are many custom exoplanet eclipse reduction pipelines, and rather than requiring you use the entire Erebus pipeline you can simply use it's FN-PCA functionality in your own code.</p>"},{"location":"demos/fnpca_systematic/#loading-fits-data-with-erebus-skip-if-you-have-your-own-file-loading-implementation","title":"Loading fits data with Erebus (skip if you have your own file loading implementation)\u00b6","text":"<p>First we will extract a 3D array of the time-series frames captured by JWST. For this we will use Erebus, which offers the <code>WrappedFits</code> object to load the frames and time information from a JWST pipeline <code>calints.fits</code> file, and the <code>fits_file_utils</code> script that includes helper methods for parsing <code>.fits</code> data.</p> <p>The WrappedFits file also performs outlier and nan removal as described in Connors et al 2025.</p>"},{"location":"demos/fnpca_systematic/#performing-fn-pca","title":"Performing FN-PCA\u00b6","text":"<p>Using either the frames contained in the Erebus WrappedFits object or from your own implementation, we can now perform FN-PCA. This method takes a 3D array of the time-series observations, as well as an aperture radius, annulus start, and annulus end (in pixels) to perform background subtraction with before normalizing the values within the aperture. The method expects the star to be centered on each frame.</p>"},{"location":"demos/full_pipeline/","title":"Full pipeline example","text":"<p>This demo will show how to load calints data downloaded from MAST and fit for the eclipse depths of each visits individually and jointly using Erebus.</p> In\u00a0[1]: Copied! <pre>from erebus import Erebus\n</pre> from erebus import Erebus <p>Erebus needs two configuration files to run: One that includes the physical parameters of the planet, and one that includes the configuration of the run.</p> <p>An example planet file can look like (detailed explanation is given on the planet configuration page:</p> <p>planet.yaml</p> <pre><code>name: LHS1478b\nt0: [2458786.75425, 0.00042]\np: [1.9495378, 0.0000041]\nrp_rstar: [0.0462, 0.0011]\na_rstar: [16.119, 0.094]\ninc: [87.452, 0.052]\necc: [0]\nw: [0]\n</code></pre> <p>An example run configuration can look like this (detailed information is given on the run configuration page):</p> <p>run_config.yaml</p> <pre><code>fit_fnpca: true\nfit_linear: true\nperform_individual_fits: true\nperform_joint_fit: true\ncalints_path: ./mast_lhs1478b\nplanet_path: ./lhs1478b.yaml\naperture_radius: 5\nannulus_start: 12\nannulus_end: 20\ntrim_integrations: [10, 40]\n</code></pre> <p>To follow along with this demo you can either a) download JWST exoplanet observations from the Barbara A. Mikulski Archive for Space Telescopes or b) clone the Erebus GitHub repo and find example data provided at <code>manual_tests/lhs1478b</code>. The <code>manual_tests</code> directory also has an example planet configuration file and run configuration file.</p> In\u00a0[2]: Copied! <pre>run = \"../../manual_tests/lhs1478b_run.yaml\"\nerebus = Erebus(run)\n</pre> run = \"../../manual_tests/lhs1478b_run.yaml\" erebus = Erebus(run) <pre>Circular orbit: using gaussian prior for t_sec\nPredicted t_sec: 0.0879+/-0.0004 days from the start of the observation\nVisit jw03730012001 already ran\nCircular orbit: using gaussian prior for t_sec\nPredicted t_sec: 0.0886+/-0.0004 days from the start of the observation\nVisit jw03730013001 already ran\nCircular orbit: using gaussian prior for t_sec_offset\nJoint fit already ran\n</pre> <p>Creating an <code>Erebus</code> pipeline object loads in all the data and caches it to the disk. Once it is loaded, we can run it. We can optionally set the output folder where Erebus will save information on the run parameters, output files for the individual and joint fits, as well as figures for visualizing the data.</p> <p>Both the <code>Erebus</code> constructor and <code>run</code> method can take in an optional <code>force_clear_cache</code> parameter to clear the cache if need be, else the <code>erebus_cache</code> folder can be deleted manually.</p> In\u00a0[3]: Copied! <pre>erebus.run(output_folder=\"./output/\")\n</pre> erebus.run(output_folder=\"./output/\") <pre>Skipping jw03730012001: already ran\nCannot make corner plot: fitting was not yet run!\nCannot make chain plot: fitting was not yet run!\nSkipping jw03730013001: already ran\nCannot make corner plot: fitting was not yet run!\nCannot make chain plot: fitting was not yet run!\nSkipping joint fit: already ran\nOffset:  0.0 hours\nCannot make corner plot: fitting was not yet run!\nCannot make chain plot: fitting was not yet run!\n</pre> <p>After running the Erebus pipeline the results are saved to the provided outputs folder. Erebus has built-in plotting routines or you can directly access the data and make your own plots.</p> In\u00a0[5]: Copied! <pre>from erebus.joint_fit_results import JointFitResults\nfrom erebus.individual_fit_results import IndividualFitResults\n\nfrom erebus.plotting import plot_joint_fit\nfrom erebus.plotting import plot_fnpca_individual_fit\n\njoint_fit = JointFitResults.load(\"./output/lhs1478b_joint_fit.h5\")\nplot_joint_fit(joint_fit, show = True)\n\nvisit_1 = IndividualFitResults.load(\"./output/lhs1478b_visit_1_jw03730013001.h5\")\nplot_fnpca_individual_fit(visit_1, show = True)\n</pre> from erebus.joint_fit_results import JointFitResults from erebus.individual_fit_results import IndividualFitResults  from erebus.plotting import plot_joint_fit from erebus.plotting import plot_fnpca_individual_fit  joint_fit = JointFitResults.load(\"./output/lhs1478b_joint_fit.h5\") plot_joint_fit(joint_fit, show = True)  visit_1 = IndividualFitResults.load(\"./output/lhs1478b_visit_1_jw03730013001.h5\") plot_fnpca_individual_fit(visit_1, show = True) <pre>Offset:  0.0 hours\n</pre> <p>Consult the API for a list of data available in each results object.</p>"},{"location":"demos/full_pipeline/#full-pipeline-example","title":"Full pipeline example\u00b6","text":""}]}